<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>src.utils.repair_simulation API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.utils.repair_simulation</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.utils.repair_simulation.fix_missing_elements"><code class="name flex">
<span>def <span class="ident">fix_missing_elements</span></span>(<span>simulation: <a title="src.utils.file_loader.SimulationFile" href="file_loader.html#src.utils.file_loader.SimulationFile">SimulationFile</a>,<br>for_fragment: MDAnalysis.core.groups.AtomGroup,<br>replace_with_mass: bool = False) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fix_missing_elements(
    simulation: SimulationFile,
    for_fragment: MDAnalysis.AtomGroup,
    replace_with_mass: bool = False,
) -&gt; bool:
    &#34;&#34;&#34;
    Attempts fix missing atomic element information in the simulation by determining atomic elements using atomic masses
    Fixing is done only on the AtomGroup provided in the arguments (not all the atoms!!)
    :param simulation: containing the fragment
    :param for_fragment: in which to fix missing atomic elements
    :param replace_with_mass: if resolution fails, replaces element names with its atomic mass
                              (in almost all cases, False)
    :return: True if all elements in fragment were distinguished confidently
    :raises AssertionError: if simulation is not loaded before
    &#34;&#34;&#34;
    new_elements: list[str] = [&#34;&#34; for _ in range(for_fragment.n_atoms)]

    all_successful: bool = True
    for i in range(for_fragment.n_atoms):
        atom_mass: float = for_fragment.masses[i]
        for element_name, element_mass in ATOMTABLE_ELEMENTS_MASSES.items():
            if is_close(
                element_mass,
                atom_mass,
                rel_tol=0,
                abs_tol=ATOMTABLE_ELEMENT_MASS_CONFIDENCE_THRESHOLD,
            ):
                new_elements[i] = element_name
                break
        else:
            if replace_with_mass:
                new_elements[i] = str(for_fragment.atoms.masses[i])
            all_successful = False

    universe: MDAnalysis.Universe = simulation.get_simulation()
    if not hasattr(simulation, &#34;elements&#34;):
        universe.add_TopologyAttr(
            &#34;elements&#34;, [&#34;&#34; for _ in range(simulation.get_simulation().atoms.n_atoms)]
        )

    for_fragment.elements = new_elements
    return all_successful</code></pre>
</details>
<div class="desc"><p>Attempts fix missing atomic element information in the simulation by determining atomic elements using atomic masses
Fixing is done only on the AtomGroup provided in the arguments (not all the atoms!!)
:param simulation: containing the fragment
:param for_fragment: in which to fix missing atomic elements
:param replace_with_mass: if resolution fails, replaces element names with its atomic mass
(in almost all cases, False)
:return: True if all elements in fragment were distinguished confidently
:raises AssertionError: if simulation is not loaded before</p></div>
</dd>
<dt id="src.utils.repair_simulation.fix_missing_names"><code class="name flex">
<span>def <span class="ident">fix_missing_names</span></span>(<span>simulation: <a title="src.utils.file_loader.SimulationFile" href="file_loader.html#src.utils.file_loader.SimulationFile">SimulationFile</a>,<br>for_fragment: MDAnalysis.core.groups.AtomGroup) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fix_missing_names(
    simulation: SimulationFile, for_fragment: MDAnalysis.AtomGroup
) -&gt; bool:
    &#34;&#34;&#34;
    Attempts fix missing atomic element information in the simulation by assigning unique names to atoms
    Fixing is done only on the AtomGroup provided in the arguments (not all the atoms!!)
    :param simulation: containing the fragment
    :param for_fragment: in which to fix missing atomic names
    :return: always True
    :raises AssertionError: if simulation is not loaded before
    &#34;&#34;&#34;

    universe: MDAnalysis.Universe = simulation.get_simulation()
    if not hasattr(universe.atoms, &#34;names&#34;):
        universe.atoms.add_TopologyAttr(
            &#34;names&#34;, [&#34;&#34; for _ in range(simulation.get_simulation().atoms.n_atoms)]
        )

    symbols: str = string.ascii_letters + string.digits
    new_names: list[str] = []
    for item in itertools.product(symbols, repeat=2):
        if len(new_names) == for_fragment.atoms.n_atoms:
            break
        new_names.append(&#34;&#34;.join(item))

    for_fragment.atoms.names = new_names
    return True</code></pre>
</details>
<div class="desc"><p>Attempts fix missing atomic element information in the simulation by assigning unique names to atoms
Fixing is done only on the AtomGroup provided in the arguments (not all the atoms!!)
:param simulation: containing the fragment
:param for_fragment: in which to fix missing atomic names
:return: always True
:raises AssertionError: if simulation is not loaded before</p></div>
</dd>
<dt id="src.utils.repair_simulation.fix_molecule_use_alternate_bonds_information"><code class="name flex">
<span>def <span class="ident">fix_molecule_use_alternate_bonds_information</span></span>(<span>for_fragment: MDAnalysis.core.groups.AtomGroup) ‑> MDAnalysis.core.groups.AtomGroup</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fix_molecule_use_alternate_bonds_information(
    for_fragment: MDAnalysis.AtomGroup,
) -&gt; MDAnalysis.AtomGroup:
    &#34;&#34;&#34;
    Attempts to extract a single molecule, given a fragment suspected to be composed of multiple molecules
    (fragment should be a single molecule already, but this has happened in older GROMACS versions)
    Beware that this function DOES NOT CHECK whether the precondition is correct and thus might produce insensible
    results
    :param for_fragment: from which to extract the molecule
    :return: MDAnalysis.AtomGroup of alternate molecule using different atom information, in an alternate universe
    :raises AssertionError: if simulation is not loaded before
    &#34;&#34;&#34;

    # molecule might be a compound of several sub-molecules bonded with hydrogen bonds, which are still
    # reported as bond information. Alternate source comes from naming of atoms, which seems to be unique

    atoms_types_to_indices: dict[str, int] = {
        name: i for i, name in enumerate(for_fragment.types)
    }

    def extract_bond_name(bond_info: str | tuple) -&gt; tuple[str, str]:
        &#34;&#34;&#34;
        Transforms string bond information &#39;(&#39;Nap&#39;, &#39;SC5p&#39;)&#39; into bond atom names (Nap, SC5p).
        Fallback if bond information is already provided as a tuple
        :param bond_info: string bond information
        :return: bond names
        &#34;&#34;&#34;
        if isinstance(bond_info, str):
            atom1, atom2 = bond_info.split(&#34;,&#34;)
            return (
                atom1.replace(&#34;&#39;&#34;, &#34;&#34;).replace(&#34;(&#34;, &#34;&#34;).strip(),
                atom2.replace(&#34;&#39;&#34;, &#34;&#34;).replace(&#34;)&#34;, &#34;&#34;).strip(),
            )
        return bond_info

    # topDict contains &#39;unique&#39; bond information, between named atoms
    bonds_alternate_str: list[tuple[str, str]] = [
        extract_bond_name(bond_info) for bond_info in for_fragment.bonds.topDict
    ]
    bonds_alternate_indices: list[tuple[int, int]] = [
        (atoms_types_to_indices[atom1], atoms_types_to_indices[atom2])
        for atom1, atom2 in bonds_alternate_str
    ]

    # we will create subset of &#39;uniquely bonded&#39; atoms
    atom_filtered_indices: list[int] = list(
        set(atom_i for bonds in bonds_alternate_indices for atom_i in bonds)
    )
    atom_filtered_indices.sort()

    # every atom will have its own residue, keeping original residue name
    alternate_atom_resindices: list[int] = list(range(len(atom_filtered_indices)))
    alternate_atom_resnames: list[str] = [
        for_fragment.atoms.resnames[i] for i in atom_filtered_indices
    ]

    # however, atoms are now indexed from 0, so we need to update bonding information appropriately
    bonds_alternate_indices_zerobased: dict[int, int] = {
        idx: i for i, idx in enumerate(atom_filtered_indices)
    }

    mol = MDAnalysis.Universe.empty(
        len(atom_filtered_indices),
        n_residues=len(alternate_atom_resindices),
        atom_resindex=alternate_atom_resindices,
        residue_segindex=[0 for _ in range(len(atom_filtered_indices))],
        trajectory=True,
    )

    mol.add_TopologyAttr(
        &#34;name&#34;, [for_fragment.types[i] for i in atom_filtered_indices]
    )  # types as the new names
    mol.add_TopologyAttr(
        &#34;type&#34;, [for_fragment.types[i][0] for i in atom_filtered_indices]
    )  # does not really matter
    mol.add_TopologyAttr(&#34;masses&#34;, [0 for _ in atom_filtered_indices])
    mol.add_TopologyAttr(&#34;elements&#34;, [&#34;&#34; for _ in atom_filtered_indices])
    mol.add_TopologyAttr(&#34;resname&#34;, alternate_atom_resnames)
    mol.add_TopologyAttr(&#34;id&#34;, list(range(len(atom_filtered_indices))))
    mol.add_TopologyAttr(&#34;resid&#34;, alternate_atom_resindices)
    mol.add_TopologyAttr(&#34;segid&#34;, [&#34;ALT&#34;])
    mol.add_TopologyAttr(
        &#34;bonds&#34;,
        [
            (
                bonds_alternate_indices_zerobased[a1],
                bonds_alternate_indices_zerobased[a2],
            )
            for a1, a2 in bonds_alternate_indices
        ],
    )
    if hasattr(for_fragment.atoms, &#34;positions&#34;):
        positions_filtered: list[tuple[float, float, float]] = [
            for_fragment.atoms.positions[atom_i] for atom_i in atom_filtered_indices
        ]
        mol.atoms.positions = positions_filtered
    return mol.select_atoms(&#34;segid ALT&#34;)</code></pre>
</details>
<div class="desc"><p>Attempts to extract a single molecule, given a fragment suspected to be composed of multiple molecules
(fragment should be a single molecule already, but this has happened in older GROMACS versions)
Beware that this function DOES NOT CHECK whether the precondition is correct and thus might produce insensible
results
:param for_fragment: from which to extract the molecule
:return: MDAnalysis.AtomGroup of alternate molecule using different atom information, in an alternate universe
:raises AssertionError: if simulation is not loaded before</p></div>
</dd>
<dt id="src.utils.repair_simulation.is_close"><code class="name flex">
<span>def <span class="ident">is_close</span></span>(<span>a, b, rel_tol=1e-09, abs_tol=0.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_close(a, b, rel_tol=1e-09, abs_tol=0.0):
    # https://stackoverflow.com/questions/5595425/how-to-compare-floats-for-almost-equality-in-python
    return abs(a - b) &lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.utils" href="index.html">src.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.utils.repair_simulation.fix_missing_elements" href="#src.utils.repair_simulation.fix_missing_elements">fix_missing_elements</a></code></li>
<li><code><a title="src.utils.repair_simulation.fix_missing_names" href="#src.utils.repair_simulation.fix_missing_names">fix_missing_names</a></code></li>
<li><code><a title="src.utils.repair_simulation.fix_molecule_use_alternate_bonds_information" href="#src.utils.repair_simulation.fix_molecule_use_alternate_bonds_information">fix_molecule_use_alternate_bonds_information</a></code></li>
<li><code><a title="src.utils.repair_simulation.is_close" href="#src.utils.repair_simulation.is_close">is_close</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
